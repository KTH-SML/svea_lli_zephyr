&cdc_acm_uart0 { // For mikroros
    current-speed = <115200>;
};

&usart1 {
    current-speed = <115200>;
};

/* For input event codes used by futaba,sbus */
#include <zephyr/dt-bindings/input/input-event-codes.h>

&usart2 {
    status = "okay";

    /* The SBUS driver configures 100000/8E2 at runtime; these are harmless */
    current-speed = <100000>;
    parity = "even";
    stop-bits = "2";
    rx-invert;              /* SBUS is inverted */
    /* optional: hw-flow-control = "none"; */

    /* Map SBUS channels to input events: 1=steer, 2=throttle, 6=gear, 5=override */
    sbus0: sbus {
        compatible = "futaba,sbus";
        status = "okay";
        ch1_steer: ch1 {
            channel = <1>;
            type = <INPUT_EV_ABS>;
            zephyr,code = <INPUT_ABS_X>;
        };
        ch2_throttle: ch2 {
            channel = <2>;
            type = <INPUT_EV_ABS>;
            zephyr,code = <INPUT_ABS_Y>;
        };
        ch5_override: ch5 {
            channel = <5>;
            type = <INPUT_EV_ABS>;
            zephyr,code = <INPUT_ABS_RX>;
        };
        ch6_gear: ch6 {
            channel = <6>;
            type = <INPUT_EV_ABS>;
            zephyr,code = <INPUT_ABS_RY>;
        };
    };
};

&i2c2 {
    status = "okay";
    clock-frequency = <I2C_BITRATE_STANDARD>; // Somethings weird with it, fast only works with too aggressive a pullup
    icm42670: icm42670@68 {
        compatible = "invensense,icm42670p";
        reg = <0x68>;
        label = "ICM42670";
        //int_gpio = <&mb4 14 GPIO_ACTIVE_HIGH>; 
        /* Required properties with legal values */
        gyro-hz = <800>;        /* pick 200 / 400 / 800 / 1600 */
        accel-hz = <800>;       /* pick 100 / 200 / 400 / 800 / 1600 */
        accel-fs = <8>;        /* full scale in g */
        gyro-fs = <2000>;       /* full scale in dps */
zephyr,deferred-init;
        status = "okay";
    };

    /* Battery monitor (TI bq769x0 family) on I2C2 */
    bq769x0: bq769x0@8 {
        compatible = "ti,bq769x0";
        reg = <0x08>;
        /* ALERT pin from BMS IC to MCU GPIO (adjust to your wiring) */
        alert-gpios = <&gpioa 8 GPIO_ACTIVE_HIGH>;
        /* Precharge control (BQ76200 PCHG) connected to PD2 */
        pchg-gpios = <&gpiod 2 GPIO_ACTIVE_HIGH>;
        status = "okay";
    };
};

&iwdg {
    status = "okay";
};

#include <zephyr/dt-bindings/pwm/pwm.h>

/* Pinmux definitions - silkscreen label in comments */
&pinctrl {
    /* PWM outputs mapping: PB8=P1, PB9=P2, PE5=P3, PE6=P4 */
    tim4_ch3_pb8: tim4_ch3_pb8    { pinmux = <STM32_PINMUX('B', 8, AF2)>;  }; // PB8 -> TIM4_CH3
    tim4_ch4_pb9: tim4_ch4_pb9    { pinmux = <STM32_PINMUX('B', 9, AF2)>;  }; // PB9 -> TIM4_CH4
    tim9_ch1_pe5: tim9_ch1_pe5    { pinmux = <STM32_PINMUX('E', 5, AF3)>;  }; // PE5 -> TIM9_CH1
    tim9_ch2_pe6: tim9_ch2_pe6    { pinmux = <STM32_PINMUX('E', 6, AF3)>;  }; // PE6 -> TIM9_CH2

    /* Other pins kept as-is if still in use elsewhere */
    tim1_ch1_pe9: tim1_ch1_pe9    { pinmux = <STM32_PINMUX('E', 9, AF1)>;  };
    tim12_ch1_ph6: tim12_ch1_ph6  { pinmux = <STM32_PINMUX('H', 6, AF9)>;  };
    tim3_ch1_pa6: tim3_ch1_pa6    { pinmux = <STM32_PINMUX('A', 6, AF2)>;  };
    tim3_ch2_pa7: tim3_ch2_pa7    { pinmux = <STM32_PINMUX('A', 7, AF2)>;  };
    tim5_ch1_ph10: tim5_ch1_ph10  { pinmux = <STM32_PINMUX('H', 10, AF2)>; };
    tim15_ch1_pe4: tim15_ch1_pe4  { pinmux = <STM32_PINMUX('E', 4,  AF2)>; };
    tim2_ch1_pa5: tim2_ch1_pa5    { pinmux = <STM32_PINMUX('A', 5, AF1)>; };
    tim2_ch2_pa1: tim2_ch2_pa1    { pinmux = <STM32_PINMUX('A', 1, AF1)>; };
};

/* PWM Output timers - silkscreen label in comments */
/* TIM2 no longer used for PWM on PB10/PB11 to avoid I2C2 conflict */
&timers2 {
    status = "okay";
};

&timers4 {
    status = "okay";
    st,prescaler = <215>;
    pwm4: pwm {
        compatible = "st,stm32-pwm";
        status = "okay";
        #pwm-cells = <3>;
        pinctrl-0 = <&tim4_ch3_pb8 &tim4_ch4_pb9>; // PB8=P1, PB9=P2
        pinctrl-names = "default";
    };
};

/* PWM Input capture timers - silkscreen label in comments */
&timers3 {
    status = "okay";
    st,prescaler = <107>;
    pwm3_in: pwm {
        compatible = "st,stm32-pwm";
        status = "okay";
        #pwm-cells = <3>;
        pinctrl-0 = <&tim3_ch1_pa6>; // MISO1
        pinctrl-names = "default";
    };
};


&timers12 {
    status = "okay";
    st,prescaler = <107>;

    pwm12_in: pwm {
        compatible = "st,stm32-pwm";
        status = "okay";
        #pwm-cells = <3>;
        pinctrl-0 = <&tim12_ch1_ph6>;   // PH6 (P4) now capture
        pinctrl-names = "default";
    };
};

&timers9 {
    status = "okay";
    st,prescaler = <215>;
    pwm9: pwm {
        compatible = "st,stm32-pwm";
        status = "okay";
        #pwm-cells = <3>;
        pinctrl-0 = <&tim9_ch1_pe5 &tim9_ch2_pe6>; // PE5=P3, PE6=P4
        pinctrl-names = "default";
    };
};

/* TIM15 is not present on STM32F745; use TIM1 instead for rear diff (PE9 TIM1_CH1) */
&timers1 {
    status = "okay";
    st,prescaler = <215>;
    pwm1: pwm {
        compatible = "st,stm32-pwm";
        status = "okay";
        #pwm-cells = <3>;
        pinctrl-0 = <&tim1_ch1_pe9>;
        pinctrl-names = "default";
    };
};

&timers5 {
    status = "okay";
    st,prescaler = <107>;
    pwm5_in: pwm {
        compatible = "st,stm32-pwm";
        status = "okay";
        #pwm-cells = <3>;
        pinctrl-0 = <&tim5_ch1_ph10>; // P5
        pinctrl-names = "default";
    };
};


#include <zephyr/dt-bindings/timer/stm32-timer.h>


/ {
    /* Board-specific constants expected by BMS lib */
    pcb {
        compatible = "bms";
        /* Adjust these to your pack and shunt */
        num-cells-max = <5>;              /* e.g. 3S-5S bq76920 */
        num-thermistors-max = <0>;        /* set 0/1/2/3 matching your wiring */
        current-max = <20>;               /* A, informational */
        shunt-res = <4000>;               /* mOhm in milli (e.g. 4 mOhm => 4000) */
        type = "CustomPack";
        version-str = "svea-v0.1";
        version-num = <1>;
    };

    /* TS1 wake control GPIO for the BMS IC (used by wake_chip.c) */
    zephyr,user {
        ts1_wake_gpios = <&gpiob 1 GPIO_ACTIVE_HIGH>; /* adjust to your wiring */
    };

    // Servo output nodes - silkscreen label in comments
    steeringservo: servo {
        compatible = "pwm-servo";
        pwms = <&pwm9 1 10000000 PWM_POLARITY_NORMAL>; // steer -> PE5 TIM9_CH1
        min-pulse = <PWM_USEC(1000)>;
        max-pulse = <PWM_USEC(2100)>;
    };
    throttleesc: throttle_esc {
        compatible = "pwm-servo";
        pwms = <&pwm9 2 10000000 PWM_POLARITY_NORMAL>; // throttle -> PE6 TIM9_CH2
        min-pulse = <PWM_USEC(1000)>;
        max-pulse = <PWM_USEC(2100)>;
    };
    gearservo: gear_servo {
        compatible = "pwm-servo";
        pwms = <&pwm4 4 10000000 PWM_POLARITY_NORMAL>; // speed -> PB9 TIM4_CH4
        min-pulse = <PWM_USEC(1000)>;
        max-pulse = <PWM_USEC(2100)>;
    };
    diffservo: diff_servo {
        compatible = "pwm-servo";
        pwms = <&pwm4 3 10000000 PWM_POLARITY_NORMAL>; // diff front -> PB8 TIM4_CH3
        min-pulse = <PWM_USEC(1000)>;
        max-pulse = <PWM_USEC(2100)>;
    };
    diffservorear: diff_servo_rear {
        compatible = "pwm-servo";
        status = "okay";
        pwms = <&pwm1 1 10000000 PWM_POLARITY_NORMAL>; // rear diff -> PE9 TIM1_CH1
        min-pulse = <PWM_USEC(1000)>;
        max-pulse = <PWM_USEC(2100)>;
    };
};


/ {
    wheel_encoders: wheel_encoders {
        compatible = "gpio-keys";
        status = "disabled"; /* Using timer capture, not gpio-keys */
        wheel_left: wheel_left {
            gpios = <&gpioc 0 GPIO_ACTIVE_HIGH>;
            zephyr,code = <INPUT_KEY_0>;
            label = "WHEEL_LEFT";
        };
        wheel_right: wheel_right {
            gpios = <&gpioi 10 GPIO_ACTIVE_HIGH>;
            zephyr,code = <INPUT_KEY_1>;
            label = "WHEEL_RIGHT";
        };
    };
};


/ {
    chosen {
        zephyr,console = &usart1;
        zephyr,shell-uart = &usart1;
    };

    aliases {
        /* RC PWM capture aliases removed: using SBUS on USART2 instead */

        wheel-left-gpio  = &wheel_left;
        wheel-right-gpio = &wheel_right;
        imu = &icm42670;
        watchdog0 = &iwdg;
    };
};
